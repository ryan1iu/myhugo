---
title: Java常量池
date: 2023-11-18T00:00:00.000Z
draft: true
---
常量池是java CLass文件结构中第一个出现的表类型数据项目，对于常量池容量n来说，其索引值范围是1~n-1,这样做的目的是`如果后面某些指向常量池的索
引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示`

主要存放两类变量：
- 字面量(Literal)
    - 文本字符串
    - 被声明为final的常量值
    - ...
- 符号引用(Symbolic Refenrences)
    - 被模块导出或开放的包
    - 类和接口的`全限定名`
    - 字段的名称和描述符
    - 方法的名称和描述符
    - `？`方法句柄和方法类型
    - `?` 动态调用点和动态常量
    - ...
`常量池中的每一项常量都是一个表，表结构的第一个字节用来标示不同的常量，每一种常量各自有着不同的数据结构`

Class文件中的方法、字段、等都需要引用**CONSTANT_Utf8_info**类型的常量来描述名称。方法和字段类型的常量实际上是一个指向**CONSTANT_Utf8_info**的指针。
例如对于**CONSTANT_Class_info**类型的常量来说，它代表一个类或者接口的符号引用，其中的name_index中保存了一个CONSTANT_Utf8_info类型常量的偏移地址。

# 访问标志
紧跟在常量池后面的两个字节，用于标示一些类或者接口层次的访问信息类还是接口、是否为Public等等）

# 类索引、父类索引、接口索引集合
这三项数据描述了该类或接口的继承关系，类索引和父类索引指向常量池中的CONSTANT_Class_info常量，通过其找到目标类
的全限定名
接口索引集合是一个集合

# 字段表集合和方法表集合
## 字段表
字段表用于描述类或者接口中声明的类级变量和实例级变量（static)的修饰符、字段名称、字段数据类型；
**修饰符**
- 作用域：
    - public\private\protected
- 实例变量还是类变量
    - static
- 可变性
    - final
- 并发可见性
    - volatile
- 可否被序列化
    - transient
修饰符可以方便的用布尔值标示
**字段数据类型**
- 基本类型
- 对象
- 数组
字段数据类型存储在常量池中，通过字段表中的descriptor_index指向，对于一个基本数据类型，都通过一个大写字母进行
标示，
对于对象类型，用字符`L`加对象的全限定名来表示
对于数组类型，每一个维度将使用一个前置的`[`字符来描述，例如"java.lang.String[][]"类型的二维数组将被记录为`[[
Ljava/lang/String;`
**字段的简单名称**
关于全限定名和简单名称
全限定名就是比较长的那种，简单名称就是短的那种，例如
```java
org/fenixsoft/clazz/TestClass; 是全限定名
TestClass就是简单名称
```
## 方法表集合
方法表和字段表的结构很相似
**方法访问标志**
- public
- private
- protected
- static
- final
- synchronized
- native
- abstract
- strictfp

## java中的方法重载
在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的
简单名称之外，还要求必须拥有一个与原方法不同的特征签名[2]。特征签名
是指一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返
回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的
不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的
范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也
就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是
可以合法共存于同一个Class文件中的。

## 属性表集合
属性表的结果是比较随意的，class文件、字段表、方法表都可以携带自己的属性表集合。
### 用于方法表的Code属性表
![](https://imagebed-1300955178.cos.ap-beijing.myqcloud.com/202311221813783.png)

- max_stack 操作数栈深度的最大值
- max_locals 局部变量所需要的存储空间，单位是槽，一个槽大小32bit，大小小于32bit的数据类型占用一个槽，大于32位的占用两个槽，方法中的参数（包括隐藏的this),try-catch语句块中catch块所定义的异常，方法体中定义的局部变量，max_locals只是指定了存储变量所需要的最大存储空间，但是实际上所有的局部变量不可能同时存在，虚拟机会在运行时将局部变量表中的变量进行重用，当代码执行超出一个变量的作用域的时候，这个局部变量的变量槽可以被其他局部变量所使用。
- code_length和code存储源代码编译之后的字节码指令，虽然code_length是32位，但实际上javac最多只允许u2数量的字节码存在 ，code是8位的用来存储字节码，目前Java虚拟机规范已经定义了大约200条编码值对应的指令含义。
- exception_table 异常表，不一定存在，结构如图所示
![](https://imagebed-1300955178.cos.ap-beijing.myqcloud.com/202311221848786.png)
尽管Java最初有为处理异常设计的跳转指令，但是Java虚拟机规范明确要求编译器通过异常表而不是跳转指令来实现Java异常和finally处理机制
当在start_pc和end_pc之间出现catch_type(指向常量表中的一个  CONSTANT_Class_info类型索引)或者其子类异常，就跳转到handler_pc进行处理。当catch_type为0时，任意异常情况都需要转到handler_pc进行处理。
## Exceptionsa属性
exceptions属性是在方法表中与Code属性平级的一项属性，作用是列举方法中可能抛出的受检异常，也就是方法描述时在throws关键字后面列举的异常。
![](https://imagebed-1300955178.cos.ap-beijing.myqcloud.com/202311221909952.png)
## LineNumberTable属性
描述java源代码行号和字节码偏移量的对应关系
## LocalVariableTable及LocalVariableTypeTable属性
LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系，如果没有生成这项属性，`最大的影响就是，当别人引用这个方法时，所有的参数名称都会消失，调试期间无法根据参数名称从上下文中获得参数值`
![](https://imagebed-1300955178.cos.ap-beijing.myqcloud.com/202311221947869.png)

LocalVariableTypeTable跟上面那个基本一样，只不过上面那个的descriptor_index指向的是描述符表，而typeTable指向的是一个签名，这是因为为了适应泛型的引入，当泛型引入之后，仅仅通过描述符就无法准确地描述一个本地变量的类型信息了。


















